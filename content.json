{"pages":[],"posts":[{"title":"一家公司的好坏，先看HR部门","text":"面对茫茫的公司，如何去判断一家公司是否靠谱呢？ 除非你关注一家公司很久了或有内线，不然光从面试过程中你真的很难说这家公司好与坏。我会比较看重HR部门，为什么？ 1.我老婆就是资深HR，深知这个部门的重要性，和被忽视性。 2.如果整个面试沟通过程中，HR部门显得很薄弱，说明该公司的组织架构不清晰，处于混沌阶段，有风险。 3.如果HR部门的素质不够，那么入职了，我也觉得后续会有麻烦，比如交金、请假等等的沟通也比较头疼。 HR需要情商智商双在线，如果一家公司拥有这样的HR说明它重视这个部门，为看似不赚钱的部门买了不少单，说明公司盈利或者业务稳定。就如，肚子饿了，只要能填饱肚子基本什么都会吃（精力只有在业务赚钱上），而真的去吃山珍海味说明有钱（会有精力把其它相关部门做好）。好的HR是对公司和员工的双保险！一些小经历 记得很多年前，手上同时拿到了盛大创新院和某社交平台的offer，该平台HR电话问我意向，我说我去创新院，她接着问我地址，我说在浦东软件园（入职的项目组正好从总部搬出来）。这HR就很嘲讽的语气说盛大在张江怎么在什么软件园呢，一顿巴拉巴拉。从此之后该社交平台我就再也不用了，确实这几年这平台不怎么样了。 前几天去某中型公司（两、三百号人左右），技术上方向不太符合，HR都没把我送出门，我从很内部的会议室自己摸索着出门，从中感受出该公司的冷漠。 有时候HR太高冷了，毕竟不是聊技术有话题，又是伤感情的薪酬环节，不知道怎么聊了，之前聊得再愉快到了这戛然而止。 电话通知我拿到offer了，但是电话那头先把我贬下，然后提出薪资结构等等。既然我不好，为什么给我offer呢？此地无银三百两的告诉我你要我去，但要压我价嘛。其实很多时候既然能谈到这部基本双方都有意向了，薪资是一方面，还有其他，避重就轻的说点吸引人的东西，不是更好，增加砝码吗？一个HR在多次和面试者沟通后，还不知道面试者除了薪资还想要什么，那么是失败的。 面试别不耐烦，多与不同人聊是好事，也是学习 聊得人越多，你越能知道公司和团队的素质，是否和自己匹配。 有些面试官做技术做产品太久了，不太和陌生人打交道，说的话、问的问题常常情商不在线，给我的感觉就是要花很长时间和团队磨合，一般自己心里会亮起警报。 总结 一场愉快的面试，是双方的尊重。面试者答应了就该准时出席，把自己所知所想告诉对方，自我的梳理和反思；面试官面了就该好好对待，可以从被面试者身上学到新的思维维度，把公司团队的产品介绍下，也算是一种推广。人与人相处，尤其是陌生人相处是需要有礼节的，你永远不知道坐在你对面的人，他背后有什么样的能量。","link":"/2018/07/20/the-quality-of-a-company-first-look-at-HR-department/"},{"title":"出差菲律宾","text":"入职没多久，因为菲律宾项目的版本更新，和一后端、一测试，三人组队前往当地打怪升级。 副本Loading三个半小时。 住和工到达马尼拉的时候已经快晚上9点了，下飞机弄完电话卡连上网络，急忙打车去坐落在BGC的酒店——步行离公司5MIN，一个大套房3人住，好宽敞。 BGC近年来发展很快，类似上海的陆家嘴，许多大型跨国公司变迁至此（如HSBC,Google等）。 第二天，准时打开上班，新装修的办公室还是给人眼前一亮，大大小小的会议室、工作间、沙发、游戏室、健身房、食品吧台、甚至还有临时休息的房间。 吃菲律宾的餐饮感觉还是偏西餐的，油炸类的偏多，行程中吃的比较多；中餐的话基本是港式、台湾的为主，第一天晚上夜宵就是著名的鼎泰丰，味道不错。这边的水，大多是生水，国人也许喝不惯，一般在BGC一顿饭花费在1500Php左右，好一点的日料什么的那就更贵了。 因为回国航线有史诗级台风「山竹」经过，所以在菲律宾多待2天，有机会去海边逛逛随便去吃海鲜，我们去的市场感觉主要做国人生意，到处是中国人，东南亚的海鲜品种差不多，买的时候可以讨价还价。 行对于我们这些初来乍到的，还是出租车比较靠谱，机场出来还是黄色（貌似机场特有）的出租车比较靠谱，虽然贵但是没发生坐地起价或者绕路等问题，之前同事来坐白色出租车虽然起步便宜但是最后付钱的时候比我们贵很多。或者用Grab打车（类似滴滴打车），价格合理。 菲律宾特色“吉普尼”，五颜六色装饰夸张，是与黑色伦敦出租车和黄色纽约出租车齐名的交通工具，可惜没乘坐。 周边在BGC的时候感觉道路很干净，路上没有什么垃圾，甚至找个垃圾桶都很难，常常领着一袋垃圾从A处到B处目的地才有垃圾桶扔，路上没看到有人抽烟等；去之前很担心安全问题，国内常有报道，到那里后感觉很多时候没必要过于担心。 谈不上安保能力多强，平时的安检还是很多的，进大楼、酒店、商场都有安检，类似上海地铁安检吧，机器扫描或者人工打开包看，人工看的话基本都是带手套或者用一个小木棍，避免直接与物品直接接触，避免不必要的麻烦。几天下来没有谁不做检查的，不像地铁安检经常有人不愿意或者争执，其实无论在菲律宾还是国内，安检只是防君子不防小人的（和门一样），但是它也是一道保护大家的屏障，所以我们应该尊重它，而不是敌对它。 总结原本出差7天，后拜台风“山竹”所赐，多待了2天，得以有机会去海边或者更多地方逛逛。整体给我的感觉很不错，物价和上海总体差不多，若不是语言的不同，很多时候感觉自己是生活在魔都，当然天气也会常常提醒你:)。期待下次再去！","link":"/2018/09/24/traveling-to-the-philippines/"},{"title":"CSS、JS文件对网页的影响","text":"我们常说浏览器是单线程的，那么我们在加载资源的时候页面是在等待加载完成呢？还是继续执行后续的操作？加载不同资源对浏览器的操作会有相同响应吗？我们可以通过一个一个简单的实验测试来了解。 环境所有资源均在localhost，浏览器chrome 69，不同浏览器或版本会有少许不同 – css css1.css 2秒后返回 body { background-color: #444 } css2.css 立即返回 body { font-size: 50px;font-weight: bold; } – js js1.js 1秒后返回 console.log(“js1.js loaded”) js2.js 立即返回 console.log(“js2.js loaded”) js3.js 3秒后返回 console.log(“js2.js loaded”) – image img1.png 3秒后 返回一张黄色js图片 img2.png 立即返回一张 nodejs图片 服务器端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const Koa = require('koa')const Router = require('koa-router')const views = require('koa-views')const fs = require('fs')const app = new Koa()const router = new Router()app.use(views(__dirname + '/views'))router.get('/', async (ctx, next) =&gt; &#123; await ctx.render('index.html')&#125;)router.get('/css1.css', async ctx =&gt; new Promise(resolve =&gt; &#123; setTimeout(function () &#123; ctx.set('Content-Type', 'text/css') ctx.body = 'body &#123; background-color: #444 &#125;' resolve() &#125;, 1000 * 2)&#125;))router.get('/css2.css', async ctx =&gt; &#123; ctx.set('Content-Type', 'text/css') ctx.body = 'body &#123; font-size: 50px;font-weight: bold; &#125;'&#125;)router.get('/js1.js', async ctx =&gt; new Promise(resolve =&gt; &#123; setTimeout(function () &#123; ctx.body = 'console.log(\"js1.js loaded\")' resolve() &#125;, 1000)&#125;))router.get('/js2.js', async ctx =&gt; &#123; ctx.body = 'console.log(\"js2.js loaded\")'&#125;)router.get('/js3.js', async ctx =&gt; new Promise(resolve =&gt; &#123; setTimeout(function () &#123; ctx.body = 'console.log(\"js3.js loaded\")' resolve() &#125;, 1000 * 3)&#125;))router.get('/img1.png', async ctx =&gt; new Promise(resolve =&gt; &#123; setTimeout(function () &#123; ctx.set('Content-Type', 'image/png; charset=UTF-8') ctx.body = fs.createReadStream('1.png') resolve() &#125;, 1000 * 3)&#125;))router.get('/img2.png', async ctx =&gt; &#123; ctx.set('Content-Type', 'image/png; charset=UTF-8') ctx.body = fs.createReadStream('2.png')&#125;)app .use(router.routes()) .use(router.allowedMethods())app.listen(3000) 实验一： CSS加载是否影响DOM解析index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('test') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function() &#123; const el = document.getElementById('app') console.log(el) &#125;, 0) &lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css1.css\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css2.css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt; &lt;img style=\"width: 100px\" src=\"/img1.png\" /&gt; &lt;img style=\"width: 100px\" src=\"/img2.png\" /&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; console.timeEnd('test')&lt;/script&gt;&lt;/html&gt;&lt;!-- console 输出app元素对象test: 1947.620849609375ms--&gt; 从控制台的输出可以看到 app 元素会被正确输出，2秒左右再输出 test 的时间，可见CSS加载并不会阻碍DOM解析。 实验二： CSS加载是否影响JS执行和DOM渲染index.html 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('test') &lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css1.css\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css2.css\" /&gt; &lt;script type=\"text/javascript\" src=\"/js1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt; &lt;img style=\"width: 100px\" src=\"/img1.png\" /&gt; &lt;img style=\"width: 100px\" src=\"/img2.png\" /&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; console.timeEnd('test')&lt;/script&gt;&lt;/html&gt;&lt;!-- console 输出js1.js loadedjs2.js loaded(index):17 test: 1921.02099609375ms--&gt; 当打开index.html页面后，会发现所有资源均同时发起了请求，页面会先处于白屏加载状态（DOM无法渲染），当2秒（左右）后页面除img1.png未渲染外，其它样式和图片均渲染。 从控制台的输出可以看出，虽然js比css快1秒左右加载完毕，但是此刻是处于阻塞状态并没有执行，当css加载完成后，才从上至下的执行（虽然js2.js比js1.js早加载好，但是执行的时候还是从上至下的），当css1.css加载完成后，页面立即渲染，图片img1.png晚1秒左右显示。可见CSS加载会阻碍JS执行和DOM的渲染。 实验三： JS加载是否影响DOM解析和渲染index.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('test') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function() &#123; const el = document.getElementById('app') console.log(el) &#125;, 0) &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js3.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt; &lt;img style=\"width: 100px\" src=\"/img1.png\" /&gt; &lt;img style=\"width: 100px\" src=\"/img2.png\" /&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; console.timeEnd('test')&lt;/script&gt;&lt;/html&gt;&lt;!-- console 输出nulljs3.js loadedtest: 2943.9951171875ms--&gt; 我们仅引入一个js3.js文件，设置它的返回时间为3秒，从控制台的输出可以看到 app 元素没有被正确输出（输出null），3秒左右再输出 test 的时间，可见JS加载会阻碍DOM解析，既然解析都被影响自然必定影响渲染了。 实验四： DOM的DOMContentLoaded和onLoad事件index.html 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('test') console.time('testDOMContentLoaded') console.time('testonload') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) window.onload = function () &#123; console.timeEnd('testonload') &#125; &lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css1.css\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/css2.css\" /&gt; &lt;script type=\"text/javascript\" src=\"/js1.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"/js2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt; &lt;img style=\"width: 100px\" src=\"/img1.png\" /&gt; &lt;img style=\"width: 100px\" src=\"/img2.png\" /&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; console.timeEnd('test')&lt;/script&gt;&lt;/html&gt;&lt;!-- console 输出js1.js loadedjs2.js loadedtest: 1955.489990234375mstestDOMContentLoaded: 1956.044189453125mstestonload: 2964.078857421875ms--&gt; 我们通过控制台会发现 testDOMContentLoaded 会在2秒左右打印出来，testonload会在3秒左右打印出来，由此可知DOMContentLoaded是js和css文件的加载后触发，onload是整个页面所有资源加载完后触发（比如图片等）。 实验五： script async 属性index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('testDOMContentLoaded') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function() &#123; const el = document.getElementById('app') console.log(el) &#125;, 0) &lt;/script&gt; &lt;script async type=\"text/javascript\" src=\"/js1.js\"&gt;&lt;/script&gt; &lt;script async type=\"text/javascript\" src=\"/js2.js\"&gt;&lt;/script&gt; &lt;script async type=\"text/javascript\" src=\"/js3.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3个js文件都加上”async”,会发现输出顺序是 testDOMContentLoaded 会立即打印出来 app元素对象 js2.js loaded js1.js loaded js3.js loaded 之后我们将js1.js上的”async”移除，会发现输出顺序是 el 为 null js1.js loaded testDOMContentLoaded 1秒左右时间 js2.js loaded js3.js loaded 之后我们将js3.js上的”async”移除，会发现输出顺序是 el 为 null js1.js loaded js2.js loaded js3.js loaded testDOMContentLoaded 3秒左右时间 可见async会打乱js的执行顺序，有async的js文件哪个先加载完哪个先执行，DOMContentLoaded的触发时间不在和async有关系，不会影响页面的渲染和解析 实验六： script defer 属性index.html 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('testDOMContentLoaded') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; setTimeout(function() &#123; const el = document.getElementById('app') console.log(el) &#125;, 0) &lt;/script&gt; &lt;script defer type=\"text/javascript\" src=\"/js1.js\"&gt;&lt;/script&gt; &lt;script defer type=\"text/javascript\" src=\"/js2.js\"&gt;&lt;/script&gt; &lt;script defer type=\"text/javascript\" src=\"/js3.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3个js文件都加上”defer”,会发现输出顺序是 app元素对象 js1.js loaded js2.js loaded js3.js loaded testDOMContentLoaded 3秒左右时间 这和没有加defer和async时一样 之后我们将js1.js上的”defer”移除，会发现输出顺序是 el 为 null js1.js loaded js2.js loaded js3.js loaded testDOMContentLoaded 3秒左右时间 这和没有加defer和async时一样 之后我们将js3.js上的”defer”移除，会发现输出顺序是 js1.js loaded js3.js loaded js2.js loaded testDOMContentLoaded 3秒左右时间 可见defer会打乱js的执行顺序，有defer的js文件会晚于没有的，但是它们（含有defer）依旧保持从上而下依次执行，DOMContentLoaded的触发时间晚于defer，不会影响页面的渲染和解析 实验七： script defer &amp; async 都加上 属性index.html 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('testDOMContentLoaded') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) &lt;/script&gt; &lt;script async defer type=\"text/javascript\" src=\"/js1.js\"&gt;&lt;/script&gt; &lt;script async defer type=\"text/javascript\" src=\"/js2.js\"&gt;&lt;/script&gt; &lt;script async defer type=\"text/javascript\" src=\"/js3.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3个js文件都加上”async”,会发现输出顺序是 testDOMContentLoaded 会立即打印出来 js2.js loaded js1.js loaded js3.js loaded async优先级比defer高 实验八： 动态创建scriptindex.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('testDOMContentLoaded') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) setTimeout(function () &#123; var appEl = document.getElementById('app') console.log(appEl) &#125;, 0) &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var head = document.getElementsByTagName('head')[0] for (var i = 0; i &lt; 3; i++) &#123; var script = document.createElement('script') script.type = 'text/javascript' script.src = 'js' + (i + 1) + '.js' head.appendChild(script) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; testDOMContentLoaded 会立即打印出来 appEl 对象 js2.js loaded js1.js loaded js3.js loaded 如果我们动态创建js1.js和js2.js，将js3.js依旧按照常规写法写在页面中的话 index.html1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; console.time('testDOMContentLoaded') &lt;/script&gt; &lt;script type=\"text/javascript\"&gt; document.addEventListener('DOMContentLoaded', function () &#123; console.timeEnd('testDOMContentLoaded') &#125;, false) setTimeout(function () &#123; var appEl = document.getElementById('app') console.log(appEl) &#125;, 0) &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js3.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var head = document.getElementsByTagName('head')[0] for (var i = 0; i &lt; 2; i++) &#123; var script = document.createElement('script') script.type = 'text/javascript' script.src = 'js' + (i + 1) + '.js' head.appendChild(script) &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;hello world&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; appEl 为 null 立即打印出来 js3.js loaded testDOMContentLoaded 3秒左右会立即打印出来 js2.js loaded js1.js loaded 可见动态创建script基本是同时加载，哪个先加载完哪个先执行，但是他们都晚于DOMContentLoaded事件 总结CSS加载会阻塞DOM渲染和JS执行，但是不影响页DOM解析；JS加载会阻塞DOM解析和渲染，给script标签加上defer &amp; async属性将不再影响DOM解析和渲染，async 是哪个先返回先执行按个，defer会晚于常规标签同时按照含有defer属性的script加载的顺序执行","link":"/2018/09/30/js-css-image-loading/"},{"title":"前端错误捕获提交错误日志","text":"为什么需要捕获？前端代码运行在客户端的浏览器里，当客户端（浏览器）出现任何问题，在没有错误日志的情况下，我们都是不知道问题发生在哪，我们只能依靠猜测或者自己不断尝试才知道，或者永远不知道问题。 客户端怎么捕获？1.通过window.onerror，可惜只能获得基础的js错误，Promise、async/await 里的错误无法捕获，它收到同源决策的影响 2.Promise 通过catch方法 3.async/await 通过 try - catch 4.Vue可以通过全局Vue.config.errorHandler去获得非Promise、async/await里的错误，可以理解为Vue里的window.onerror 不同的捕获错误用法（测试环境 chrome &amp; https://jsbin.com）window.onerror123456789window.onerror = function(message, source, lineno, colno, error) &#123; /* message：错误信息（字符串）。可用于HTML onerror=\"\"处理程序中的event。 source：发生错误的脚本URL（字符串） lineno：发生错误的行号（数字） colno：发生错误的列号（数字） error：Error对象（对象） */&#125; 12345678910111213141516window.onerror = function () &#123; console.log(arguments)&#125;let datalet info = data.info/* console 输出[object Arguments] &#123; 0: \"Uncaught TypeError: Cannot read property 'info' of undefined\", 1: \"yiveral.js\", 2: 6, 3: 17, 4: [object Error] &#123; ... &#125;&#125;*/ 虽然onerror无法捕获Promise里的错误，但是如果Promise里面是被setTimeout包裹的js还是能捕获的 12345678910111213141516171819202122232425262728293031323334353637window.onerror = function () &#123; console.log(arguments)&#125;function timer () &#123; setTimeout(function () &#123; let data let info = data.info &#125;, 100)&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; timer() &#125;).catch(function (error) &#123; console.log(error) console.log('inner error') &#125;)&#125;p().then(function() &#123; console.log('running then')&#125;).catch(function(error)&#123; console.log(error) console.log('outer error')&#125;)/* console 输出[object Arguments] &#123; 0: \"Uncaught TypeError: Cannot read property 'info' of undefined\", 1: \"yiveral.js\", 2: 8, 3: 22, 4: [object Error] &#123; ... &#125;&#125;*/ Promise catchQ：如果没有catch方法，是否能捕获Promise里的错误？1234567891011121314151617181920212223242526window.onerror = function () &#123; console.log(arguments) console.log('onerror')&#125;function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; errorFn() &#125;)&#125;try &#123; p().then(function(res) &#123; console.log('running then') &#125;)&#125; catch (e) &#123; console.log(e) console.log('try - catch')&#125;/* console 没有任何输出*/ 我们通过上面的代码发现，Promise里的错误无论在try - catch还是onerror里都无法被捕获 123456789101112131415161718192021222324252627282930313233function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; errorFn() &#125;).catch(function (error) &#123; console.log(error) console.log('inner error') return 'return inner error' &#125;)&#125;try &#123; p().then(function(res) &#123; console.log(res) console.log('running then') &#125;).catch(function(error)&#123; console.log(error) console.log('outer error') &#125;)&#125; catch (e) &#123; console.log(e) console.log('try - catch')&#125;/* console 输出[object Error] &#123; ... &#125;\"inner error\"\"return inner error\"\"running then\"*/ 通过上面代码发现，已经被捕获的错误代码，在外层不会再被捕获而是继续执行then里的方法，可见在一条Promise链上的错误，会被之后最近的catch捕获。 async/await 通过 try - catch123456789101112131415161718192021window.onerror = function () &#123; console.log(arguments)&#125;function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; errorFn() &#125;)&#125;(async function () &#123; let res = await p() console.log(res)&#125;)()/* console 没有任何输出*/ 我们通过上面的代码发现，Promise构造函数里的错误并没有被onerror捕获 1234567891011121314151617181920212223window.onerror = function () &#123; console.log(arguments)&#125;function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; resolve('resolve') &#125;)&#125;(async function () &#123; let res = await p() console.log('get res') errorFn()&#125;)()/* console 输出get res*/ 虽然Promise正常执行，但是当后续的代码出错onerror依旧没有被捕获 123456789101112131415161718192021222324function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; errorFn() &#125;)&#125;(async function () &#123; try &#123; let res = await p() console.log(res) &#125; catch (e) &#123; console.log(e) console.log('try - catch') &#125;&#125;)()/* console 输出[object Error] &#123; ... &#125;\"try - catch\"*/ try - catch捕获了 1234567891011121314151617181920212223242526272829function errorFn () &#123; let data let info = data.info&#125;function p() &#123; return new Promise(function (resolve, reject) &#123; errorFn() &#125;).catch(function (error) &#123; console.log(error) console.log('inner error') return 'return inner error' &#125;)&#125;(async function () &#123; try &#123; let res = await p() console.log(res) &#125; catch (e) &#123; console.log(e) console.log('try - catch') &#125;&#125;)()/* console 输出[object Error] &#123; ... &#125;\"inner error\"\"return inner error\"*/ 从上面代码我们知道，如果Promise构造函数里的错误被它自己catch的话，那么 async/await 后续的 try - catch将不再对它捕获 Vue.config.errorHandler12345Vue.config.errorHandler = function (err, vm, info) &#123; // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用&#125; 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 我们该如何去理解官方对errorHandler的解释呢？通过 vue-cli构建工具，创建一个非常基础的vue项目，做一些实验。 测试代码库：https://github.com/miser/vue-capture-error 在main.js 1234Vue.config.errorHandler = function (err, vm, info) &#123; console.log(arguments) console.log('vue errorHandler')&#125; 在App.vue 12345678910111213141516171819&#123; // ... created () &#123; this.normal() &#125;, methods: &#123; normal () &#123; let data let info = data.info &#125; &#125; // ... &#125;/* 刷新页面 console 输出0: TypeError: Cannot read property 'info' of undefined at VueComponent.normal …1: VueComponent &#123;_uid: 1, _isVue: true, $options: &#123;…&#125;, _renderProxy: Proxy, _self: VueComponent, …&#125;2: \"created hook*/ 从上面代码可以看出，errorHandler确实可以满足我们的需求，在一个统一的地方捕获代码的错误，但是真的如此吗？上文也提到errorHandler和window.onerror类似，那么当我们使用Promse或者async/await时会不会得愿以偿。 js中的异步很大一部分来自网络请求，那么在这我们用 axios （它做了一层ajax与Promise之间的封装）。 main.js里添加 1234567891011121314const request = axios.create()request.interceptors.response.use(response =&gt; &#123; return response&#125;)Vue.request = (args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; request(args).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125; 在App.vue 123456789101112131415&#123; // ... created () &#123; this.fetch1() &#125;, methods: &#123; fetch1 () &#123; Vue.request('https://api1.github.com/') .then(response =&gt; &#123; console.log(response) &#125;) &#125; &#125; // ... &#125; api.github.com 会返回 github的api列表，当我们拼错域名，比如上面代码中的api1.github.com时，那肯定是无法获得我们想要的，可是errorHandler并没有获得该错误，不过幸好，我们可以在全局统一的Vue.request里的catch方法去统一捕获网络层面的错误。那如果是非网络层面的呢？比如数据请求回来了，但是绑定数据的时候，后端因为业务的修改等原因并没有返回我们需要的字段，造成Promise.then方法的业务处理错误。 在App.vue 12345678910111213141516&#123; // ... created () &#123; this.fetch2() &#125;, methods: &#123; fetch2 () &#123; Vue.request('https://api.github.com/') .then(response =&gt; &#123; let data = response.data let info = data.api.info &#125;) &#125; &#125; // ... &#125; 上诉代码运行后，errorHandler同样未能捕获错误，从vue的issue里面去查询关于捕获Promise或者async/await时，会得到作者的答复: https://github.com/vuejs/vue/issues/6551 Vue cannot capture errors that are thrown asynchronously, similar to how try… catch won’t catch async errors. It’s your responsibility to handle async errors properly, e.g. using Promise.catch — @yyx990803 那么该怎么办，不可能每个地方都加Promise.catch方法吧！ https://github.com/vuejs/vue/issues/7653 @Doeke 在这个地方给出一个解决方案，通过全局mixin，给那些Promise方法外面包一层Promise，在这个外层Promise链上catch里面的错误，不过这样需要做代码的约定，就是原来的方法需要返回一个Promise对象。 main.js里添加@Doeke的思路 12345678910111213141516171819202122232425262728Vue.mixin(&#123; beforeCreate: function () &#123; const methods = this.$options.methods || &#123;&#125; Object.entries(methods).forEach(([key, method]) =&gt; &#123; if (method._asyncWrapped) return const wrappedMethod = function (...args) &#123; const result = method.apply(this, args) const resultIsPromise = result &amp;&amp; typeof result.then === 'function' if (!resultIsPromise) return result return new Promise(async (resolve, reject) =&gt; &#123; try &#123; resolve(await result) &#125; catch (error) &#123; if (!error._handled) &#123; const errorHandler = Vue.config.errorHandler errorHandler(error) error._handled = true &#125; reject(error) &#125; &#125;) &#125; wrappedMethod._asyncWrapped = true methods[key] = wrappedMethod &#125;) &#125;&#125;) 在App.vue 123456789101112131415161718192021222324&#123; // ... created () &#123; this.fetch2() this.fetch3() &#125;, methods: &#123; fetch2 () &#123; Vue.request('https://api.github.com/') .then(response =&gt; &#123; let data = response.data let info = data.api.fetch2 &#125;) &#125;, fetch3 () &#123; return Vue.request('https://api.github.com/') .then(response =&gt; &#123; let data = response.data let info = data.api.fetch3 &#125;) &#125; &#125; // ... &#125; 通过运行并观察console打印可以看出，fetch3的错误被errorHandler捕获，而fetch2的错误并没有。 那么Promise里的错误统一捕获的问题差不多应该解决了，那么async/await的呢？ 在App.vue 123456789101112131415161718192021&#123; // ... created () &#123; this.fetch4() this.fetch5() &#125;, methods: &#123; async fetch4 () &#123; let response = await Vue.request('https://api.github.com/') let data = response.data let info = data.api.fetch4 &#125;, async fetch5 () &#123; let response = await Vue.request('https://api.github.com/') let data = response.data let info = data.api.fetch5 return response &#125; &#125; // ... &#125; fetch4并没有返回Promise，fetch5返回的也不是Promise对象，但是当运行的时候我们会发现fetch4和fetch5的错误信息都被捕获了，这是为什么呢？因为async/await本身就是Promise的语法糖，在 babeljs 官网的 “Try it out” 尝试用 async/await，你会发现最后编译后的代码就是在外包了一层Promise。 在哪里捕获更为优雅？（尽量以更少的代码覆盖大部分或者全部代码）网络层：可以在axios.create创建的实例中 逻辑层：非Promise本身就会被errorHandler捕获；Promise相关的可以通过全局mixin给返回Promise对象的方法做一个外层包装，统一catch并调用errorHandler处理（这个方法的是否有副作用还需要研究!） 捕获的错误存放在哪？# 自己简易服务 ？ 感觉成本很大（人力和工时） # 官方推荐的 Sentry 注册后安装官方的JS SDK 1npm install raven-js --save 修改main.js 1234567891011121314151617181920212223// ...import Raven from 'raven-js'import RavenVue from 'raven-js/plugins/vue'Raven .config('https://1dfc5e63808b41058675b4b3aed4cfb6@sentry.io/1298044') // sentry token .addPlugin(RavenVue, Vue) .install()Vue.config.errorHandler = function (err, vm, info) &#123; Raven.captureException(err)&#125;Vue.request = (args) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; request(args).then(res =&gt; &#123; resolve(res) &#125;).catch(err =&gt; &#123; Raven.captureException(err) reject(err) &#125;) &#125;)&#125;// ... 修改App.vue （我们从最普通的js测试起）12345678910// ...created () &#123; this.normal() // this.fetch1() // this.fetch2() // this.fetch3() // this.fetch4() // this.fetch5()&#125;// ... 打开sentry页面查看我们通过上面2张图片可以看出，sentry自带一个简单的issue管理功能，此外详情页面的错误栈已经方便我们知道问题出在哪里了。 测试fetch1的ajax请求错误 除了fetch2无法被捕获外（之前提过，它没有返回Promise对象），其它的都能被捕获。不过Promise和async/await的错误栈比较少。尤其是Promise.then里的错误，如下2张图的对比： 除了默认的数据的收集外，还能收集一些其他数据，比如用户信息 1234Raven.setUser(&#123; name: 'miser name', id: 'miser id' &#125;) 我们测试了代码未被压缩的情况，如果代码压缩了呢？ 显然我们不能直观的获得错误定位，不过sentry提供SourceMaps存储服务，它能方便的debug被压缩的代码。 我们可以通过webpack-sentry-plugin工具将整个上传过程写进webpack里，因为我们的实验环境是vue3，所以我们创建一个vue.config.js文件 1234567891011121314const SentryPlugin = require('webpack-sentry-plugin')module.exports = &#123; configureWebpack: &#123; plugins: [ new SentryPlugin(&#123; organization: 'fe-org', // 组织名称 类似公司名吧（一个用户下可以有多个组织） project: 'popcorn-vue', // 项目名称 （一个组织下可以有多个项目） apiKey: '17c7d61a800f495c803196e2c02cadeb1b41454247db4f06a5c54193510da150', release: '1.2.4-beta' // 发布后的代码和这个对应，可以找到这个sourcemaps &#125;) ] &#125;&#125; 修改main.js123456Raven .config('https://1dfc5e63808b41058675b4b3aed4cfb6@sentry.io/1298044', &#123; release: '1.2.4-beta' // 新增 &#125;) .addPlugin(RavenVue, Vue) .install() 1npm run build 查看sentry里popcorn-vue项目中的版本 我们打开build完的index.html，虽然错误成功捕获但依旧和上图的一样，无法被SourceMaps解析，大概的原因是js和js.map的目录结构问题。 这个issue https://github.com/getsentry/sentry-electron/issues/54 是一个很经典的例子，它犯了2个错误 – 仅仅传了js.map而没有传被压缩的js文件，它们应该一一对应的上传到服务器上– js和js.map目录路径不匹配 这2个原因都会导致无法正常解析被压缩的文件。 那么不直接通过浏览器打开index.html（file:///**/vue-capture-error/dist/index.html），通过nginx去模拟正式环境。12brew install nginxnginx 将build出的代码dist拷贝到nginx默认目录下 /usr/local/var/www/，打开浏览器http://localhost:8080 回到sentry中查看新的错误记录 我们需要捕获那些信息？Todo… 数据存在第三方是否会有敏感数据泄露问题？Todo… 如何去设计这个类库？Todo…","link":"/2018/10/23/js-capture-error/"}],"tags":[],"categories":[{"name":"工作","slug":"工作","link":"/categories/工作/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"}]}